.\" Manpage for specs.
.\" Open an issue at https://github.com/yoavnir/specs2016 to correct errors or typos
.mso www.tmac
.TH man 1 "1 Apr 2020" "0.6" "specs man page"
.SH NAME
specs \- a text processing tool
.SH SYNOPSIS
specs [switches] spec-units
.SH DESCRIPTION
.B specs
is a command line utility for parsing and re-arranging text input. It allows re-alignment of fields, some format conversion, and re-formatting multiple lines into single lines or vice versa. Input comes from standard input, and output flows to standard output.
.P 
This is a re-writing of the specs pipeline stage from CMS, only changed quite a bit.
.P 
This version is liberally based on the CMS Pipelines User's Guide and Reference
.URL "https://publib.boulder.ibm.com/epubs/pdf/hcsj0c30.pdf"
-- especially chapters 16, 24, and 20.

.SS "Spec Units"
.B Spec Units 
are the building blocks of a 
.B specs
.I specification.
Each spec unit tells the 
.B specs
engine to perform some action. The most common spec unit is a 
.I data field
which consists of five arguments, three of which may be omitted:
.P
.RS 5
[fieldIdentifier] InputPart [conversion] OutputPart [alignment]
.RE
.P

A 
.B fieldIdentifier 
is a single letter followed by a colon (like
.I a:
), that maps to the input or output of a single data field unit for later reference such as
in later data fields or in 
.I expressions. 
If the fieldIdentifier is at the start of the data field unit, it contains the input. It it
is the OutputPart, it contains the output.  For example:
.RS 5
a: w1 ucase b:
.RE
.I a
contains the first word of the input, while 
.I b
contains an uppercase version of 
.I a

The 
.B InputPart
argument may be any of the following:
.RS 3
.P
A range of characters, such as `5`, `3-7`, or `5.8`, the last one indicating 8 characters starting in the 5th position. Note that the indexing of characters is 1- rather than 0-based.
.P
A range of words, such as `w5` or `words 5-7`, where words are separated by one or more `wordseparator` characters -- locale-defined whitespace by default. The word indexing is 1-based.
.P
A range of fields, such as `fields 5` or `f5-7`, where fields are separated by exactly one `fieldseparator` characters -- a tab by default. The field indexing is 1-based.
.P 
.B TODclock
-- A 64-bit formatted timestamp, giving microseconds since the Unix epoch.
.P 
.B DTODclock
-- A 64-bit formatted timestamp, giving microseconds since the Unix epoch. The difference is that TODclock shows the time when this run of
.I specs
begun, while DTODclock gives the time of producing the current record.
.P
.B NUMBER
-- A record counter as a 10-digit decimal number.
.P
.B TIMEDIFF
-- A 12-digit decimal number indicating the number of microseconds since the invocation of the program.
.P
The 
.B ID
keyword followed by a previously defined 
.B FieldIdentifier.
.P
The 
.B PRINT
keyword followed by a calculated expression.
.B PRINT
can be replaced by a question mark (
.B ?
) either as its own command-line token or prefixing the calculated expression.
.P
A string literal, optionally enclosed by delimiters, such as `/TODclock/` or `'NUMBER'`. Note that to include the single quotes on the command line requires you to enclose them in double quotes.
.P
A 
.B SUBSTring
of another InputPart.
.RE
    
The 
.B OutputPart
argument specifies where to put the source:
.RS 3
.P
Absolute position (such as `1`) with no limit on output length.
.P
A range (such as `1-5` or `1.5`)
.P
.B N 
or
.B NEXT
for placing the output immediately after the previous output.
.P
.B NW 
or
.B NEXTWORD
for placing the output following a space character after the previous output.
.P
.B NF
or
.B NEXTFIELD
for placing the output following a tab character after the previous output.
.P 
A field identifier specification such as 
.B a:
or
.B C:
\&.
.RE
    
The alignment argument can be `l`, `c`, or `r`, for
.B left
,
.B center
, and
.B right
respectively. Yes, you can use the entire word. In fact, for compatibility with other countries, you can even spell it
.B centre.
.RE
    
The 
.B OutputPart
argument can also be specified as a 
.B Composed Output Placement
argument. It is enclosed in non-optional parenthesis and includes 1, 2, or 3 comma-separated expressions. Those expressions are evaluated at each cycle to produce the starting column, the field width, and the alignment of the field.  If the parenthesis include only one expression, that expression is the starting column. If it contains two expressions, those expressions are the starting column and the width. A width of zero is a special value denoting the normal width of the output. If all three expressions are present, the last one is evaluated as a string, and the alignment will be determined by the value. It will be centered if the argument begins with a capital or lower-case 'c', right-aligned if the value begins with a capital or lower-case 'r', and left-aligned in all other cases.  If the alignment field is two characters in length, the second character is a digit between
.I 1-5,
and the content is longer than the output field, the truncation will use an ellipsis as follows: For a value of
.I 1, 
.B specs 
will output an ellipsis followed by the suffix of the content; for
.I 5,
.B specs
will output a prefix followed by an ellipsis; for 
.I 2, 3, 
and
.I 4,
.B specs
will output a prefix, an ellipsis and a suffix, with the prefix being one third, one half, or two thirds of the output string respectively.  If a composed output placement argument appears in a particular data field, neither a regular OutputPlacement nor an Alignment argument may appear.  The first arguments in a composed output placement can be elided, as in 
.I (,,'R'). 
If that is done, the default for the output start is the next place, equivalent to the function 
.I next(), 
while the default for the second argument is the rest of the line, based on the 
.I @cols
label.

The conversion argument can specify any of the following conversions:
.IP "rot13" 3
Encrypts the bytes using the ROT-13 cipher.
.IP "C2B" 3
Converts characters to binary: "AB" --> "0010000100100010".
.IP "C2X" 3
Converts characters to hexadecimal: "AB" --> "4142".
.IP "B2C" 3
Converts binary to characters: "0010000100100010" --> "AB". Will throw an exception if called with an invalid character.
.IP "X2CH" 3
Converts hexadecimal to characters: "4142" --> "AB". Will throw an exception if called with an invalid character.
.IP "b2x" 3
Converts binary data to hex.
.IP "D2X" 3
Convert decimal to hex: "314159265" --> "12b9b0a1".
.IP "X2D" 3
Convert hex to decimal: "12b9b0a1" --> "314159265".
.IP "ucase" 3
Converts text to uppercase.
.IP "lcase" 3
Converts text to lowercase.
.IP "BSWAP" 3
Byte Swap. reverses the order of bytes. "AB" --> "BA"
.IP "ti2f" 3
Convert internal time format (8-byte microseconds since the epoch) to printable format using the conventions of strftime, plus %xf for fractional seconds, where x represents number of digits from 0 to 6.
.IP "tf2i" 3
Convert printable time format to the internal 8-byte representation. 
.IP "s2tf" 3
Convert a decimal number with up to six decimal places, representing seconds since the epoch, to printable format using the conventions of strftime, plus %xf for fractional seconds, where x represents number of digits from 0 to 6.
.IP "tf2s" 3
Convert printable time format to a decimal number, representing seconds since the epoch. 
.IP "mcs2tf" 3
Convert a number, representing microseconds since the epoch, to printable format using the conventions of strftime, plus %xf for fractional seconds, where x represents number of digits from 0 to 6.
.IP "tf2mcs" 3
Convert printable time format to a number, representing microseconds since the epoch. 

.SS "Other Spec Units"
There are also other spec units, that may be used:
.IP "READ" 3
Causes the program to read the next line of input. If we have already read the last line, the read line is taken to be the empty string.
.IP "READSTOP" 3
Causes the program to read the next line of input. If we have already read the last line, no more processing is done for this iteration.
.IP "UNREAD" 3
Causes the program to push back the current active record back to the reader, so that the next iteration of the specification or the next 
.I READ
or
.I READSTOP
spec unit will read it back.  This is useful when looping with READ searching for the next line to run the specification on.
.IP "WRITE" 3
Causes the program to write to output and reset the output line.
.IP "NOWRITE" 3
Causes the program not to suppress the write at the end of the cycle.
.I NOPRINT
is a synonym for 
.I NOWRITE
.IP "NOPRINT" 3
A synonym for 
.I NOWRITE
.IP "ASSERT" 3
Followed by a condition, this keyword halts the specification immediately if the condition evaluates to 
.B false
or zero. The normal use of assertions is to make sure that the read data or the internal state makes sense. 
.IP "ABEND" 3
The 
.I ABnormal END 
keyword is used to abruptly end the run of the specification. The token that follows the ABEND token is output in the error message. ABEND units make sense only within conditionals as they are never part of the normal processing or a record.
.IP "WORDSEPARATOR and FIELDSEPARATOR" 3
Declare a character to be the word of field separator respectively, which affects word and field ranges. For WORDSEPARATOR it is possible to use the special value 
.I default
to make all whitespace defined by the locale work as a word separator. 
.IP "REDO" 3
Causes the current output line to become the new input line.
.IP "SET" 3
Followed by an assignment operation, SET implements this and assigns a value to one of the system counters. See the Expressions and Assignments section.
.IP "CONTINUE" 3
Causes the specification to stop and go on to the next record. If any output has been made, it is dumped to output.  This is typically used in an 
.B IF
block.
.IP "SKIP-WHILE and SKIP-UNTIL" 3
Either of these statements causes the specification to skip input lines
.B while
a condition is true, or
.B until
if becomes false. More precisely, the specification stops and goes to the next record, similar to the 
.B CONTINUE
unit, but once the condition for passing occurs once, the condition is never evaluated again and future records are passed unchecked. It usually only makes sense to place 
.B SKIP-WHILE
and
.B SKIP-UNTIL
units at the beginning of the specification.

.SS "MainOptions"
These are optional spec units that appear at the beginning of the specification and modify the behavior of the entire specification.
.IP "STOP" 3
This option is followed by either the keyword
.B ALLEOF,
the keyword
.B ANYEOF,
or a number indicating an input stream. This indicates when the specification stops. The default is
.B ALLEOF
which means that the specification terminates when every input stream is exhausted. When some but not all of the streams are exhausted, those that are get treated as if they emit empty records. With 
.B ANYEOF
the specification terminates when any of the streams is exhausted. With a numeric value the specification terminates when the specified stream is exhausted. Other streams, if exhausted are treated as if they emit empty records.
.IP "PRINTONLY" 3
This option instructs 
.B specs
to suppress output records unless a specified
.I break level
is established. The break level is either a field identifier (case matters) or it can be the keyword
.B EOF 
which specifies records are suppressed until the input is exhausted or the condition specified with 
.B STOP 
is satisfied.
.IP "KEEP" 3
This option, always following 
.B PRINTONLY
instructs
.B specs
not to reset the output buffer when a record in not output due to break level not being established. This allows the content from several records to be aggregated into a single output record.

.SS "Conditions and Loops"
A specification can include conditions and loops. 

Conditions begin with the word 
.B if
followed by an 
.B expression 
that evaluates to true of false, followed by the token
.B then,
followed by some 
.B Spec Units.
Those will be executed only if the condition evaluates to true. They may be followed by an
.B else
token followed by more
.B Spec Units 
that will be executed if the expression is not true, or they may be followed by an
.B elseif
token with its own condition, 
.B then 
token, and set of 
.B Spec Units.
The chain of 
.B elseif
tokens may be arbitrarily long, but there may only be at most one 
.B else
token. The conditional block ends with an
.B endif
token.  For example:

.RS 5
.B if
#2 > 5
.B then 
.RS 4
/big/ 1
.RE 
.B elseif
#2 > 3
.B then 
.RS 4
/medium/ 1
.RE
.B else 
.RS 4
/small/ 1
.RE 
.B endif
.RE

The loop available in 
.B specs
is a 
.B while
loop.  It begins with the 
.B while
token, followed by an 
.B expression 
that evaluates to true of false, followed by the token
.B do,
and a series of 
.B Spec Units
that will be executed as long as the expression evaluates to true. The series of 
.B Spec Units is terminated by the token
.B done.
Example:

.RS 5
.B while
#2 > 0
.B do
.RS 4
print /#2/ 1
.RS 1
.RE 
write
.RS 1
.RE 
set /#2 -= 1/
.RE
.B done
.RE

.SS "Control Breaks"
The 
.B Field Identifiers
have another use. When used with the
.B BREAK
keyword or the 
.B break()
function they act as flow control. A 
.B break level 
is 
.I established
when the value of the corresponding field identifier changes from the previous iteration. For
example, consider a three-field CSV file where the first field is the department name, the second is 
the employee's first name, and the third is his or her last name.  Suppose further that the file is 
sorted by department name. You can print this out without repeating the department name like this:

          FIELDSEPARATOR ,
       c: FIELD 1   .
          FIELD 3  10
          /,/      NEXT
          FIELD 2  NEXTWORD
          BREAK c
              ID c 1

.SS "RunIn and RunOut Cycles"
A 
.B cycle 
is defined as a single run of the specification, which includes reading an input record, processing it, and outputting one or more records. If the specification contains 
.B read 
or 
.B readstop 
tokens, a single cycle can consume more than one input records.

The 
.B runin 
cycle is the first one to run. In the runin cycle, the function 
.B first()
returns 1. This can be used for initial processing such as printing of headers or setting initial values. 

The 
.B runout 
cycle happens 
.I after 
the last line has been read.  It consists of the spec items that follow the 
.B EOF 
token, or (when 
.I select second 
is used) conditional specifications with the 
.B eof() 
function. Example:

    if first() then
        /Item/  1  /Square/ nw write
        /====/  1  /======/ nw write
    endif
    a:  w1 1.4 right
        print "a*a" 6.6 right
        set '#0+=(a*a)'
    EOF
        /==========/ 1 write
        /Total:/ 1
        print #0 nw
        
.SS "Input Streams"
The keyword 
.B SELECT
along with the keywords 
.B FIRST
and
.B SECOND 
can be used to select between two input stations. The 
.B FIRST 
input station is the regular primary input. The
.B SECOND 
input station holds the previous record from the primary input.

Imagine an input stream that has the natural numbers. Let's run the following specification:

    specs w1 1 /- 1 =/ NW SELECT SECOND w1 nw
    
The result will be the following:
    1 - 1 =
    2 - 1 = 1
    3 - 1 = 2
    4 - 1 = 3
    5 - 1 = 4

and so on.

The keyword
.B SELECT
can also be used with a number between 1 and 8 to denote different input streams. These extra streams are specified with the
.B --is2 - --is8
command-line switches to specify the files that contain the other input streams. Every cycle of the specification begins with 
.B specs
set to stream #1.  For example, suppose we have two files: f1 and f2, both of which contain lists of numbers, and we want to add them:

    specs -i f1 --is2 f2 a: W1 1 '+' NW  SELECT 2  b: W1 NW  '=' NW  "?a+b" NW
    
If both files contained the natural numbers we would get the following output:
    1 + 1 = 2
    2 + 2 = 4
    3 + 3 = 6
    4 + 4 = 8
    5 + 5 = 10

and so on.

.SS "Output Streams"
The keyword
.B OUTSTREAM
can be used to select between multiple output streams. Output stream number #1 is the primary default output stream. Output streams #2 through #8 can be files specified with the
.B --os2 - --os8
command-line switches.  There is one additional output stream, which is the standard error.  It is selected with the keyword
.B STDERR
for a total of up to 9 output streams.  Example:

    ls -l | specs --os2 filesizes --os3 owners 
                W9 1 WRITE 
                OUTSTREAM 2 W5 1 WRITE
                OUTSTREAM 3 w3 1
                
This specification will print the list of owners to file 
.I owners
the file sizes to file
.I filesizes
and the file names to standard output.

.SS "Expressions and Assignments"
Expressions are used in PRINT data units as well as in assignments. Assignments are used in SET Spec Units.

Expressions are made up of numbers, field identifiers (no colon needed), and counter numbers preceded by a hash mark. They allow ordinary arithmetic and logical operations as well as function calls for pre-defined functions:
.IP "Unary Operators" 3
+ (plus - does nothing), - (minus), ! (logical NOT)
.IP "Binary Arithmetic Operators" 3
+, -, *. / (division), // (integer division), % (remainder)
.IP "Binary String Operator" 3
|| (string append)
.IP "Binary Arithmetic/String Logical Operators" 3
<, >, <=, >=, =, !=
.IP "Binary Strict Logical Operators" 3
<<, >>, <<=, >>=, ==. !==
.IP "Binary Logical Operators" 3
& (AND), | (OR)

.P 
Assignments assign the result of an expression into a 
.I numbered counter. 
For example:

	#3 := b+3
.P	
Assignment can also be used as expressions. When used as such, the value returned is the content of the counter after executing the assignment. For example, the following specification:

    specs print "#0:=2+2" 1
    
OR

    specs "?#0:=2+2" 
    
will output 4.  The assignment is performed and the value stored in the counter.
	
.IP "Assignment Operators" 3
:=, +=, -=, *=, /=, //=, %=, ||=

.IP "At-sign (@) Operator" 3
The at-sign allows the inclusion of user-defined and system-defined labels as strings in expressions. The double at-sign (@@) substitutes for the entire input record.

.SS "Built-In Functions"
.IP "abs(x)" 3
The absolute function returns the absolute value of the number passed to it. Will return an integer if the parameter is integer, or float otherwise.
.IP "ceil(x), floor(x), round(x,d)" 3
These function return the closest numbers to 
.I x
:
.B ceil
returns a whole number no smaller than 
.I x
;
.B floor
returns a whole number no greater than 
.I x
;
.B round
returns a the number closest to 
.I x
with up to
.I d
decimal places. If 
.I d
is omitted, 
.B round 
returns the closest whole number.
.IP "fact(n)" 3
The
.B fact
function returns the factorial of 
.I n
.IP "combinations(n,k) and permutations(n,k)" 3
These function give the number of ways in which 
.I k
elements can be chosen from a set of 
.I n
elements. The difference is that with 
.B combinations
the order of the elements within the subgroup (or the order in which they were selected) 
does not matter, while with
.B permutations,
it does. For example, if we are choosing 2 elements from a group of 6,
.B permutations
will return 30, because there are 6 ways to choose the first element and 5 to choose the 
second element. On the other hand, 
.B combinations
will return 15, because it doesn't matter which of the two chosen elements was chosen first.
.IP "fmt(value,format,digits,decimal,separator)" 3
The
.B fmt
function formats a floating-point
.B value
as a string. The 
.B format 
argument can be omitted, or it can begin with 
.I f
for a 
.I fixed 
number of 
.B digits
after the decimal point, or
.I s
for 
.I scientific
notation. When omitted, the 
.B digits
argument sets the total number of digits displayed. The 
.B decimal
argument sets the character used for the decimal point (default is a period), while the 
.B separator
argument sets the character used as thousands separator (default is none).
.IP "pow(x,y)" 3
The power function returns x to the power of y. Much like arithmetic operations, if either operand is float, the result is a float. If both operands are integers, the result is an integer. Otherwise, if both operands are whole numbers, the result is integer, otherwise it is float.
.IP "rand(x)" 3
The random function returns a random integer value between 0 up to and not including 
.B x.
If 
.B x
is omitted, returns a random
.I real
value no smaller than 0.0 and smaller than 1.0.
.IP "sin(x), cos(x), tan(x), dsin(x), dcos(x), dtan(x)" 3
These trigonometric functions return the sine, cosine and tangent of an angle.
.B sin, cos,
and
.B tan
accept an argument in radians, while
.B dsin, dcos,
and
.B dtan 
accept an argument in degrees.
.IP "arcsin(x), arccos(x), arctan(x), arcdsin(x), arcdcos(x), arcdtan(x)" 3
These trigonometric functions return the inverse sine, cosine and tangent.
.B arcsin, arccos,
and
.B arctan
return an angle in radians, while
.B arcdsin, arcdcos,
and
.B arcdtan 
return an angle in degrees.
.IP "exp(x) and log(x,base)" 3
These return the 
.B exponent 
of x or the 
.B logarithm 
of x. By default, the logarithm function returns the 
.I natural 
log.
.IP "string(x)" 3
Returns the same value as the argument, but forced to be stored as a string. There is nothing preventing this from later evaluating as a number, so
.I string(3)+2
will evaluate to 5.
.IP "substitute(haystack,needle,subst,max)"
Returns the string in 
.I haystack
where occurences of 
.I needle
are replaced by the string 
.I subst
for at most 
.I max
(by defualt: 1) times. The special value 
.B """U"""
for 
.I max
is used to indicate that all occurrences should be replaced.
.IP "sqrt(x)" 3
The square root function always returns a float.
.IP "c2u(x)" 3
Returns an unsigned decimal number from the binary representation of x.
.IP "c2d(x)" 3
Returns a signed decimal number from the binary representation of x.
.IP "c2f(x)" 3
Returns a floating point number assuming that x is a binary representation of a floating point number in the native encoding of the platform. On most platforms valid lengths are 4, 8, and 16 bytes (32, 64, and 128 bits).
.IP "frombin(x)" 3
Returns a decimal number from the binary representation in x.
.IP "tobine(x,d)" 3
Returns a binary representation of the unsigned integer in x with field of length d bits. Valid values for d are 8, 16, 32, and 64.
.IP "tobin(x)" 3
Returns a binary representation of the unsigned integer in x. The field length is automatically determined by the value of x, but will be 1, 2, 4, or 8 characters in length.
.IP "length(x)" 3
Returns the length of the argument when viewed as a string. For example, len(37) is 2; len('hello') is 5.
.IP "first()" 3
Returns 1 during the 
.B runin
cycle, and zero otherwise.
.IP "eof()" 3
Returns 1 during the
.B runout 
cycle, and zero otherwise.
.IP "number()" 3
Returns the number of times the specification has so far been run on different records.
.IP "recno()" 3
Returns the number of input records that have been read so far. If the specification contains no 
.I READ
or
.I READSTOP
spec units, then this number will be equal to the result of 
.B number().
Otherwise, it will be higher.
.IP "record()" 3
Returns the entire input record. Equivalent to 
.B range(1,-1)
.IP "range(s,e)" 3
Returns the range of characters from
.B s
(default first) to 
.B e 
(default last) from the input record. If the end of the range exceeds the end, truncates the result at the end. If the start of the range exceeds the end, or if the start is smaller than the end, returns NaN.
.IP "wordcount()" 3
Returns the count of words in the input record.
.IP "word(i)" 3
Returns the i-th word in the input record.
.IP "wordstart(i)" 3
Returns the starting position of the i-th word in the input record.
.IP "wordend(i)" 3
Returns the ending position of the i-th word in the input record. 
.I range(wordstart(i),wordend(i))
is equivalent to 
.I word(i)
but less efficient.
.IP "wordrange(s,e)" 3
Returns the string from the start of the 
.B s-th
word (default first) to the end of the 
.B e-th 
word (default last). It is also equivalent to 
.I range(wordstart(s),wordend(e))
but less efficient.
.IP "fieldcount()" 3
Returns the count of fields in the input record.
.IP "field(i)" 3
Returns the i-th field in the input record.
.IP "fieldstart(i)" 3
Returns the starting position of the i-th field in the input record.
.IP "fieldend(i)" 3
Returns the ending position of the i-th field in the input record. 
.I range(fieldstart(i),fieldend(i))
is equivalent to 
.I field(i)
but less efficient.
.IP "fieldrange(s,e)" 3
Returns the string from the start of the 
.B s-th
field (default first) to the end of the 
.B e-th 
field (default last). It is also equivalent to 
.I range(fieldstart(s),fieldend(e))
but less efficient.
.IP "tf2mcs(string,format)" 3
Converts a string containing a date and time representation using the format specified in the 
.I format
argument to a floating point or integer number representing the number of microseconds since the UNIX epoch. Formatting is as described for the similarly named conversion.
.IP "mcs2tf(microseconds,format)" 3
Converts a number (integer or float) representing the number of microseconds since the UNIX epoch to a printable format.
.IP "tf2s(string,format)" 3
Converts a string containing a date and time representation using the format specified in the 
.I format
argument to a floating point or integer number representing the number of seconds since the UNIX epoch. Formatting is as that of tf2mcs.
.IP "s2tf(seconds,format)" 3
Converts a number (integer or float) representing the number of seconds since the UNIX epoch to a printable format.
.IP "x2d(string,length)" 3
Returns the value in 
.I string
converted to decimal. If 
.I length is missing or non-positive, the resulting decimal is signed, otherwise it is unsigned.
.IP "next()" 3
Returns the column of the next character to print if a
.I spec unit
specifies the 
.B NEXT
position.

.SS "Built-In String Functions"
.IP "abbrev(information, info, len)" 3
Returns
.I 1
if 
.B information
begins with the first
.B len
characters of 
.B info
or 
.I 0 
otherwise. If
.B len
is omitted, all of 
.B info 
is considered.
.IP "substr(bigstring, start, length)" 3
Returns a substring of 
.I bigstring
starting at offset 
.I start
with a length of 
.I length
. If the length exceeds the end of the string, it is truncated. As always in 
.B specs
the indexes are 1-based. Negative indexes can be used to indicate offsets from the end of the string.
.IP "left(bigstring, length)" 3
Returns
.I length
characters starting at the beginning of 
.I bigstring.
If the length exceeds the length of bigstring, the result will be right-padded with blanks. If the 
length is negative, the length of the string + 1 will be added to it, so 
.B left(bigstring,-3)
is the entire string less the last two characters.
.IP "right(bigstring, length)" 3
Returns the last
.I length
characters of 
.I bigstring.
If the length exceeds the length of bigstring, the result will be left-padded with blanks. If the 
length is negative, the length of the string + 1 will be added to it, so 
.B right(bigstring,-3)
is the entire string less the first two characters.
.IP "center(bigstring, length)" 3
Returns
.I length
consecutive characters from
.I bigstring
as centered as possible in the string. If the length exceeds the length of bigstring, the result will be right-padded and left-padded with blanks. If the 
length is negative, the length of the string + 1 will be added to it, so 
.B center(bigstring,-3)
is the entire string less the first and last characters. This function can also be spelled 
.B centre
because the CMS Pipelines version also does so.
.IP "pos(needle, haystack)" 3
Returns the 1-based index of the 
.B first 
position of 
.I needle
in 
.I haystack. Note that if the 
.I haystack
argument is omitted, it defaults to the entire input line.
.IP "lastpos(needle, haystack)" 3
Returns the 1-based index of the 
.B last 
position of 
.I needle
in 
.I haystack.
Note that if the 
.I haystack
argument is omitted, it defaults to the entire input line.
.IP "includes(haystack, needle1 [,needle2, needle3, needle4])" 3
Returns
.B TRUE
(1) if the string 
.I haystack
includes the string
.I needle1
or one of the other optional 
.I needle2, needle3,
or
.I needle4
as a substring, or 
.B FALSE
(0) otherwise. To clarify, the function returns true if
.B any
of the needles match. Note that if the 
.I haystack
argument is omitted, it defaults to the entire input line.
.IP "includesall(haystack, needle1 [,needle2, needle3, needle4])" 3
Returns
.B TRUE
(1) if the string 
.I haystack
includes the string
.I needle1
and all of the other defined optional
.I needle2, needle3,
or
.I needle4
as substrings, or 
.B FALSE
(0) otherwise. To clarify, the function returns true if
.B all
of the needles match. Note that if the 
.I haystack
argument is omitted, it defaults to the entire input line.
.IP "rmatch(string, regEx [,matchFlags])" 3
Returns 
.B TRUE
(1) if the regular expression
.I regEx
matches the string
.I string,
or 
.B FALSE
(0) otherwise. See the special section below for more info on regular expressions. Note that if the 
.I string
argument is omitted, it defaults to the entire input line.
.IP "rsearch(string, regEx [,matchFlags])" 3
Returns 
.B TRUE
(1) if the regular expression
.I regEx
matches some substring of the string
.I string,
or 
.B FALSE
(0) otherwise. See the special section below for more info on regular expressions. Note that if the 
.I string
argument is omitted, it defaults to the entire input line.
.IP "rreplace(string, regEx, fmt [,matchFlags])" 3
Returns the string 
.I string,
with all matches of the regular expression 
.I regEx
replaced by what's in
.I fmt.
See the special section below for more info on regular expressions. Note that if the 
.I string
argument is omitted, it defaults to the entire input line.
.IP "conf(key,default)" 3
Returns the configured string from either the built-in configured strings such as 
.I version
or from the 
.B $HOME/.specs
file. If the string is not defined, returns the
.I default
value. If that is not defined, returns
.B NaN.
.IP "defined(key)" 3
Returns 
.B TRUE
(1) if the configured string 
.I key
is defined, or 
.B FALSE
(0) otherwise.
.IP "getenv(name)" 3
Returns the content of the environment variable 
.I name
or
.B NaN
if the environment variable of that name is not defined.
.IP "pset(var,value)" 3
Sets the
.B persistent variable
with the name in 
.I var
to the value
.I value
The value will be set in future invocations of 
.B specs.
The function returns the value in 
.I value. 
.IP "pget(var,default)" 3
Returns the value of the
.B persistent variable
with the name in
.I var
If the variable is not defined, it returns the 
.I default
value. If that is unspecified, returns 
.B NaN.
It is also possible to use the variable name preceded by a hash mark, as in 
.I #var
as an abbreviated alternative to
.I pget(var)
.IP "pdefined(var)" 3
Returns 
.B TRUE
(1) if the
.B persistent variable
.I var
is defined, or 
.B FALSE
(0) otherwise.
.IP "pclear(var)" 3
Clears the 
.B persistent variable
.I var.
Returns the value before clearing it. If the variable was not defined, returns
.B NaN.
.IP "sfield(str,n,sep)" 3
Returns the n-th field of string
.I str
counting from the start or end of the string depending on the sign of n. Separator is the first char of 
.I sep
if specified and non-empty, or 
.B tab
otherwise.
.IP "lvalue(str,sep)" 3
Returns the left hand side of strings such as 
.B pi=3.14159265. 
For this input it will return the string 
.B pi. 
.I sep 
defaults to the equals sign, but can be overridden for input strings such as 
.B idnum:543
.IP "rvalue(str,sep)" 3
Returns the right hand side of strings such as 
.B pi=3.14159265. 
For this input it will return the string 
.B 3.14159265. 
.I sep 
defaults to the equals sign, but can be overridden for input strings such as 
.B idnum:543
.IP "sword(str,n,sep)" 3
Returns the n-th word of string
.I str
counting from the start or end of the string depending on the sign of n. Separator is the first char of 
.I sep
if specified and non-empty, or 
.B space
otherwise.

.SS "Built-In REXX-Derived Functions"
.IP "bitand(x,y)" 3
Returns the bit-wise 
.B AND
of 
.I x
and 
.I y
If the length is not equal, the return string has the minimum length.
.IP "bitor(x,y)" 3
Returns the bit-wise 
.B OR
of 
.I x
and 
.I y
If the length is not equal, the return string has the minimum length.
.IP "bitxor(x,y)" 3
Returns the bit-wise 
.B XOR
of 
.I x
and 
.I y
If the length is not equal, the return string has the minimum length.
.IP "compare(s1,s2,pad)" 3
Returns the index of the first mis-matched character in strings 
.I s1
and
.I s2.
If the strings are equal, the function returns
.B zero.
If the strings are of unequal length, the shorter string is padded with the pad character (by default - space).
.IP "copies(string,times)" 3
Returns the content of
.I string 
repeated
.I times
times.
.IP "delstr(string,start,length)" 3
Deletes the substring of 
.I string 
that starts at position 
.I start 
for the specified 
.I length. 
If 
.I length 
is zero, the rest of the string is deleted from position start to the end.
.IP "delword(string,start,length)" 3
Deletes the substring of 
.I string 
that starts at position 
.I start 
and is of length 
.I length 
blank-delimited words. If 
.I length 
is zero, it defaults to removing the rest of the words in 
.I string.
.IP "find(string,phrase)" 3
Returns the word number of the first occurrence of 
.I phrase 
in 
.I string. 
Returns 0 if 
.I phrase 
is not found. Multiple blanks between words are treated as one in comparisons.
.IP "index(haystack,needle,start)" 3
Returns the character position of 
.I needle
within string
.I haystack. 
Returns 0 if 
.I needle 
is not found. If positive, 
.I start tells where in
.I haystack 
to initiate the search. It defaults to 1 if not specified. The standard
.B pos 
function should be used instead of 
.B index 
if possible.
.IP "insert(string,target,position,length,pad)" 3 
Inserts 
.I string
into 
.I target
at position 
.I position 
and truncated or padded with 
.I pad
characters to length 
.I length. 
With default or zero values, 
.I position 
inserts the 
.I string 
at the start of 
.I target, 
and the length of the 
.I string
is kept as is. The 
.I pad
defaults to a space.
.IP "justify(string,length,pad)" 3
Evenly justifies words within 
.I string. 
The 
.I length
specifies the length of the returned string, while
.I pad
specifies what padding (by default a space) to insert (if necessary).
.IP "overlay(string1, string2 ,start ,length ,pad)" 3
Returns a copy of 
.I string2, 
partially or fully overwritten by 
.I string1. start 
specifies the starting position of the overlay. 
.I length 
truncates or pads 
.I string1 
prior to the operation, using 
.I pad 
as the pad character.
.IP "reverse(string)" 3
Returns a copy of a 
.I string 
with its characters reversed.
.IP "sign(number)" 3
Returns 1 if the 
.I number 
is positive, 0 if the 
.I number 
is 0, and -1 if the 
.I number 
is negative.
.IP "space(string,length,pad)" 3
Formats a 
.I string 
by replacing internal blanks with 
.I length 
occurrences of the 
.I pad 
character. The default pad character is blank and the default length is 1. Leading and trailing blanks are always removed. If 
.I length 
is 0, all blanks are removed.
.IP "strip(string,option,char)" 3
Returns 
.I string 
stripped of leading and/or trailing blanks or any other 
.I char 
specified. 
.I Option 
values determine the action:
.B L
for leading, 
.B T
for trailing, and
.B B
for both (the default).
.IP "subword(string,start,length)" 3
Returns the substring that begins at blank-delimited word 
.I start. 
If
.I length is omitted, it defaults to the remainder of the string.
.IP "translate(string,tableout,tablein,pad)" 3
Returns a translated copy of 
.I string. 
Characters are translated according to the input translation table 
.I tablein 
and its output equivalent, 
.I tableout. 
If 
.I tablein 
and 
.I tableout 
are not coded, all characters in 
.I string 
are translated to uppercase. If 
.I tableout 
is shorter than 
.I tablein, 
it is padded with the 
.I pad 
character or its default, blanks.
.IP "verify(string, reference ,option ,start)" 3
Verifies that all characters in 
.I string 
are members of the 
.I reference 
string. Returns the position of the first character in 
.I string
that is not in 
.I reference, 
or 0 if all characters in 
.I string 
are in 
.I reference. 
.P
.I start 
specifies where in 
.I string 
to start the search, the default is 1. The option may be:
.RS 3
.P
.B N 
or Nomatch — Default. Works as described earlier.
.P
.B M
or Match — Returns the position of the first character in string that is in reference.
.IP "wordindex(string,wordno)" 3
Returns the character position of the first character of the blank-delimited word given by word number 
.I wordno 
within 
.I string. 
Returns 0 if the word numbered 
.I wordno 
does not exist in the 
.I string.
.IP "wordlength(string,wordno)" 3
Returns the length of the blank-delimited word given by word number 
.I wordno 
within 
.I string. 
Returns 0 if the word numbered 
.I wordno 
does not exist in the 
.I string.
.IP "wordpos(phrase, string [,start])" 3
If 
.I phrase 
is a substring of 
.I string, 
returns the word number position at which it begins. Otherwise returns 0. 
.I start 
is an optional word number within 
.I string 
at which the search starts. It defaults to 1.
.IP "words(string)" 3
Returns the number of blank-delimited words within the 
.I string.
.IP "wordwith(substr)" 3
Returns the first word of the input string that contains
.I substr
or an empty string if not found.
.IP "wordwithidx(substr)" 3
Returns the index of the first word of the input string that contains
.I substr
or zero if not found.
.IP "fieldwith(substr)" 3
Returns the first field of the input string that contains
.I substr
or an empty string if not found.
.IP "fieldwithidx(substr)" 3
Returns the index of the first field of the input string that contains
.I substr
or zero if not found.
.IP "xrange(start,end)" 3
Returns a string composed of all the characters between 
.I start 
and 
.I end 
inclusive. 
.I start 
defaults to 0x00, and 
.I end
defaults to 0xff.
.IP "split([sep], [hdr], [ftr])" 3
Returns all fields in the input line, one on each output line.  If 
.I sep 
is specified, it will be used instead of the active field separator. If 
.I hdr 
and/or 
.I ftr 
are specified, the first 
.I hdr 
fields and last 
.I ftr 
fields are omitted.
.IP "splitw([sep], [hdr], [ftr])" 3
Returns all words in the input line, one on each output line.  If 
.I sep 
is specified, it will be used instead of the active word separator. If 
.I hdr 
and/or 
.I ftr 
are specified, the first 
.I hdr 
words and last 
.I ftr 
words are omitted.


.SS "Built-In Statistical Pseudo-Functions" 
All of the below functions work on the values stored in field identifiers. You cannot place a proper expression inside the parenthesis.
.IP "present(a)" 3
Returns 
.I 1
if the
.B Field Identifier
a is set, or
.I 0
otherwise. 
.IP "sum(a)" 3
Returns the sum of all values in
.B Field Identifier
a. 
.IP "min(a)" 3
Returns the minimum of all values in
.B Field Identifier
a. 
.IP "max(a)" 3
Returns the maximum of all values in
.B Field Identifier
a. 
.IP "average(a)" 3
Returns the average (mathematical mean) of all values in
.B Field Identifier
a. 
.IP "variance(a)" 3
Returns the 
.I variance 
(the expectation of the squared deviation of a random variable from its mean) of the values in
.B Field Identifier
a. 
.IP "stddev(a)" 3
Returns the 
.I standard deviation 
(square root of the variance) of the values in
.B Field Identifier
a. 
.IP "stderrmean(a)" 3
Returns the 
.I standard error 
(standard deviation divided by sample size minus 1) of the values in
.B Field Identifier
a. 
.IP "fmap_nelem(a)" 3
Returns the number of distinct values of
.B Field Identifier
a. 
.IP "fmap_nsamples(a)" 3
Returns the number of samples collected of
.B Field Identifier
a. 
.IP "fmap_common(a)" 3
Returns the string value with most occurrences of
.B Field Identifier
a. In case of a tie, one of the values is returned.
.IP "fmap_rare(a)" 3
Returns the string value with least but non-zero occurrences of 
.B Field Identifier
a. In case of a tie, one of the values is returned.
.IP "fmap_count(a,s)" 3
Returns the number of occurences of the 
.B string 
s in
.B Field Identifier
a. 
.IP "fmap_frac(a,s)" 3
Returns the fraction of
.B Field Identifier
a values that are equal to the
.B string 
s.
.IP "fmap_pct(a,s)" 3
Returns the fraction of
.B Field Identifier
a values that are equal to the
.B string 
s.
.IP "fmap_sample(a,s)" 3
Treats the value of the 
.B string 
s as a new sample for
.B Field Identifier
a. Returns the count of occurences of s. 
.IP "fmap_dump(a,format,sortOrder,showPct)" 3
Returns a string containing a dump of the frequency map for
.B Field Identifier
a. If the frequency map is empty, returns the content of the configuration string
.B EmptyFrequencyMapMessage,
and if that is not defined, returns an empty string.
.IP "countocc(n,h)" 3
Returns the number of matches for this particular 
.B needle 
so far.
.IP "countocc_get(n)" 3
Returns the number of matches for this particular 
.B needle 
so far. No match is made here.
.IP "countocc_dump(format,sortOrder,showPct)" 3
Returns a string containing a dump of the 
.I frequency map 
used in 
.B countocc`.


.SH Regular Expressions
Regular expressions can be used with the 
.I rmatch, rsearch,
and
.I rreplace
functions. You use the 
.B --regexType
command line switch to select from a list of syntax options. The supported options are:
.IP "icase" 3
.B Case insensitive
.IP "nosubs" 3
.B No sub-expressions:
Not meaningful, but included here for completeness.
.IP "optimize" 3
.B Optimize matching:
Matching efficiency is preferred over efficiency constructing regex objects.
.IP "collate" 3
.B Locale sensitiveness:
Character ranges like 
.I [a-b] are affected by locale
.IP "ECMAScript" 3
.B ECMAScript grammar
The regular expression follows this grammar. Do not specify more than one of these.
.IP "basic" 3
.B Basic POSIX grammar
The regular expression follows this grammar. Do not specify more than one of these.
.IP "extended" 3
.B Extended POSIX grammar
The regular expression follows this grammar. Do not specify more than one of these.
.IP "awk" 3
.B Awk POSIX grammar
The regular expression follows this grammar. Do not specify more than one of these.
.IP "grep" 3
.B Grep POSIX grammar
The regular expression follows this grammar. Do not specify more than one of these.
.IP "egrep" 3
.B Egrep POSIX grammar
The regular expression follows this grammar. Do not specify more than one of these.
.P
.RE 3
The last parameter in all three functions is 
.I matchFlags.
This optional parameter is also a comma-separated list of flags. The supported flags are:
.IP "not_bol" 3
Not beginning of line
.IP "not_eol" 3
Not end of line
.IP "not_bow" 3
Not beginning of word
.IP "not_eow" 3
Not end of word
.IP "any" 3
Any match is acceptable if more than one is possible
.IP "not_null" 3
An empty 
.I string
does not match
.IP "continuous" 3
The expression must match a sub-sequence that begins at the first character. Sub-sequences must begin at the first character to match.
.IP "prev_avail" 3
Previous Available - One or more characters exist before the first one
.IP "sed" 3
.B (for rreplace only) 
Replaces using the same rules as the 
.B sed
POSIX utility
.IP "no_copy" 3
.B (for rreplace only) 
Sections that do not match are not copied
.IP "first_only" 3
.B (for rreplace only) 
Only the first occurrence is matched.

.SH DIRECTIVES
.B specs
specifications that are specified in a 
.B specFile
can include some directives that influence the processing. Directives
.I MUST
begin with a plus (+) sign on the left-most column of the line in the specification file. All directives 
.I MIUST
precede all spec units. Below are the supported directives:
.IP "+SET" 3
This directive followed by a single word and then a command-line command, sets a 
.B Configured String
to the output of the command. If the command issues multiple lines of output, only the first line is stored in the configured string. For example, the following directive may lead the configured string
.B ex1
to contain a value such as "total 120" on Unix-like systems:

    +SET ex1 ls -l
.IP "+IN" 3
This directive followed by a command runs the command and uses its output as the input stream for the specification.

.SH OPTIONS
.B specs 
supports the following switches:
.IP "--toASCII" 3
Causes output to be translated into ASCII if it's outside the range.
.IP "--force-read-input" 3
Forces specs to read every input line even if none of the spec units use it. By default it won't.
.IP "--specFile or -f" 3
Makes the program read the specification from a file rather than the command line. This is useful both for reusing specifications and for long specifications. It also relieves the plumber from having to escape a lot of characters in the specification to avoid creative interpretation by the Unix shell.
You can specify the full path of the files, or 
.B specs 
will search the 
.I SPECSPATH 
for them. The 
.I SPECSPATH 
can be set from either the environment variable 
.B SPECSPATH 
or the configuration string 
.B SPECSPATH. 
In both cases the syntax is just like the OS 
.B PATH: 
a list of directories separated by colons on Linux and Mac OS, or semicolons on Windows. When neither the environment variable nor the configuration string are set, the 
.I SPECSPATH
defaults to 
.B $HOME/specs
.IP "--verbose or -v" 3
Outputs more information when something goes wrong.
.IP "--stats"
Output statistics on run time, and records read, and on records written to standard error.
.IP "--inFile or -i" 3
Makes the program read the input records from a file rather than from standard input.
.IP "--outFile or -o" 3
Makes the program write the output records to a file rather than to standard output.
.IP "--spaceWS" 3
Makes the program treat the only spaces as the default word separator. Otherwise all locale-defined whitespace is treated as the default word separator.
.IP "--debug-alu-comp" 3
Prints out detailed information about the parsing and compiling of expressions (
.I only in debug build
).
.IP "--debug-alu-run" 3
Prints out detailed step-by-step information about the evaluation of expressions (
.I only in debug build
).   
.IP "--config or -c" 3
Changes the configuration file from the default 
.I ~/.specs
to whatever the parameter says
.IP "--set" or "-s" 3
The following argument sets a configured string. For example: 
.B specs --set hello=goodbye
will set the configured string
.B hello
to the value
.B goodbye
.IP "--timezone" 3
Changes the timezone from the default which is the current timezone to the value specified.
.IP "--recfm" 3
Sets the record format for the primary input stream. Supported options are 
.B D (delimited)
for records delimited by a character in the input stream (this is the default); 
.B F (fixed)
for records or a fixed length (see --lrecl); 
.B FD (fixed-delimited)
for records delimited as in 
.B fixed,
but truncated or padded to a fixed length.
.IP "--lrecl" 3
Sets the record length for 
.B fixed
and
.B fixed-delimited
records.
.IP "--linedel" 3
For 
.B delimited
and
.B fixed-delimited
records, sets the character that delimits the string. The OS-specific delimiter (CR+LF for Unix-like) is used if this is not specified.
.IP "--regexType" 3
Sets the syntax option for regular expressions. The parameter is a comma-separated list of syntax options. See the 
.B Regular Expressions
section for a list of valid syntax options.
.IP "--pythonFuncs" 3
Disables or enables the use of Python functions. The parameter can be: 
.B on
to force the loading of Python functions,
.B off
to disable Python functions, or
.B auto,
which is the default, and signifies that Python functions are loaded only when the parser encounters an unknown function. Note that setting the 
.I pythonDisabled 
configured literal to 
.B 1 
will disable Python functions and cannot be overridden from the command line.
.IP "--pythonErr" 3
Determines what happens when a called Python function throws an exception. The default, 
.B throw 
is for 
.I specs 
to throw its own exception and terminate. The alternatives, 
.B NaN, zero, 
and
.B nullstr 
make 
.I specs
behave as if the function returned, NaN, the integer zero, or an empty string respectively.
.IP "--help" 3
Does not run specs. Instead it displays a help message according to the parameter: 
.B help
prints general help, 
.B pyfuncs
prints the name, arguments, and docstring of all loaded python functions, 
.B builtin
prints the name, arguments, and a line of help for the built-in functions, 
.B specs 
prints a list of all specifications on the path and the comment, and a particular python function name makes 
.I help
display the arguments and docstring of that function only.

.SH CONFIGURATION FILE
.B specs
reads a configuration file by default from 
.B $HOME/.specs
.P 
This file contains some configuration options. For now, it only allows you to set user-predefined labels and three specific configuration options: 
.B timezone, 
.B locale, 
and 
.B SPECSPATH. 
For example, an entry such as this:
.P
    timezone: "Europe/Belfast"
    locale: es_ES
    SPECSPATH: /home/myself/specs:/Library/specs
    myCA: "Honest Abe's Used Cars & Certificates"
.P
allows you to issue a 
.B specs
command like this:
.P
    specs /My certificates come from/ 1 @myCA nw 
    
.SS "System-Defined Labels"
The system also defines some labels:
.IP "version" 3
This returns the version of 
.B specs, 
for example "v0.6"
.P
To find out the version of specs that you are using, use the following command:
.P 
    specs @version 1
.IP "cols" 3
contains the number of columns in the display. You can override this in the configuration file. For example, the following prints a right-justified string. 
.P
    specs /hello/ (1,@cols,'R')
.IP "rows" 3
contains the number of rows in the display. This can also be overridden in the configuration file.
.IP "python" 3
contains either 
.B Enabled
or
.B Disabled
depending on whether support for python function is available.

    
.SH EXAMPLES
`ls -l` yields this:

    total 352
    -rw-r--r--@ 1 ynir  admin    574 Aug 25  2009 Makefile
    -rw-r--r--@ 1 ynir  admin   3542 Nov 23 00:21 README
    -rw-r--r--@ 1 ynir  admin    362 Nov 19 08:31 conversion.h
    -rw-r--r--  1 ynir  admin    984 Nov 11 17:45 ls.txt
    -rw-r--r--@ 1 ynir  admin   2233 Nov 23 00:03 main.cc
    -rw-r--r--  1 ynir  admin   9412 Nov 23 00:11 main.o
    -rw-r--r--@ 1 ynir  admin   6567 Nov 23 00:09 spec_build.cc
    -rw-r--r--  1 ynir  admin  16776 Nov 23 00:11 spec_build.o
    -rw-r--r--@ 1 ynir  admin   5494 Nov 19 08:30 spec_convert.cc
    -rw-r--r--  1 ynir  admin  17004 Nov 23 00:11 spec_convert.o
    -rw-r--r--@ 1 ynir  admin  11419 Nov 23 00:10 spec_params.cc
    -rw-r--r--  1 ynir  admin  21080 Nov 23 00:11 spec_params.o
    -rw-r--r--@ 1 ynir  admin    375 Nov 11 09:29 spec_vars.cc
    -rw-r--r--  1 ynir  admin   4800 Nov 23 00:11 spec_vars.o
    -rwxr-xr-x  1 ynir  admin  36740 Nov 23 00:11 specs
    -rw-r--r--@ 1 ynir  admin   1547 Nov 23 00:10 specs.h

Let's run it though a spec:

    ls -l | specs 12-* 1 redo w2 1 w4 d2x 8.8 r w8 17
    
The first spec unit converts it to this:

    1 ynir  admin    574 Aug 25  2009 Makefile
    1 ynir  admin   3542 Nov 23 00:21 README
    1 ynir  admin    362 Nov 19 08:31 conversion.h
    1 ynir  admin    984 Nov 11 17:45 ls.txt
    1 ynir  admin   2233 Nov 23 00:03 main.cc
    1 ynir  admin   9412 Nov 23 00:11 main.o
    1 ynir  admin   6567 Nov 23 00:09 spec_build.cc
    1 ynir  admin  16776 Nov 23 00:11 spec_build.o
    1 ynir  admin   5494 Nov 19 08:30 spec_convert.cc
    1 ynir  admin  17004 Nov 23 00:11 spec_convert.o
    1 ynir  admin  11419 Nov 23 00:10 spec_params.cc
    1 ynir  admin  21080 Nov 23 00:11 spec_params.o
    1 ynir  admin    375 Nov 11 09:29 spec_vars.cc
    1 ynir  admin   4800 Nov 23 00:11 spec_vars.o
    1 ynir  admin  36740 Nov 23 00:11 specs
    1 ynir  admin   1547 Nov 23 00:10 specs.h

Then after the redo, we get this:

    ynir        23e Makefile
    ynir        dd6 README
    ynir        16a conversion.h
    ynir        3d8 ls.txt
    ynir        8b9 main.cc
    ynir       24c4 main.o
    ynir       19a7 spec_build.cc
    ynir       4188 spec_build.o
    ynir       1576 spec_convert.cc
    ynir       426c spec_convert.o
    ynir       2c9b spec_params.cc
    ynir       5258 spec_params.o
    ynir        eae spec_vars.cc
    ynir       12c0 spec_vars.o
    ynir       8f84 specs
    ynir        60b specs.h

      
Alternatively, let's arrange this on multiple lines:

    ls -l | specs w9 1 write "Owner:" 3 w3 10 write "Size:" 3 w5 10-20 r

    Makefile
      Owner: ynir
      Size:          574
    README
      Owner: ynir
      Size:         5834
    conversion.h
      Owner: ynir
      Size:          362
    list.txt
      Owner: ynir
      Size:          978
    ls.txt
      Owner: ynir
      Size:          984
    main.cc
      Owner: ynir
      Size:         2233
    main.o
      Owner: ynir
      Size:         9412

Finally, let's make our own version of the multi-column display:

    ls -l | specs w9 1 read w9 26 read w9 51
                             Makefile                 README
    conversion.h             main.cc                  main.o
    spec_build.cc            spec_build.o             spec_convert.cc
    spec_convert.o           spec_params.cc           spec_params.o
    spec_vars.cc             spec_vars.o              specs
    specs.h


.SH SEE ALSO
sed(1), awk(1)
.SH BUGS
Too many to list here, but it's getting better.
.SH AUTHOR
Yoav Nir (yoav.nir@gmail.com)
