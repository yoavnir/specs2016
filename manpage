.\" Manpage for specs.
.\" Open an issue at https://github.com/yoavnir/specs2016 to correct errors or typos
.mso www.tmac
.TH man 1 "1 Oct 2019" "0.5-alpha" "specs man page"
.SH NAME
specs \- a text processing tool
.SH SYNOPSIS
specs [switches] spec-units
.SH DESCRIPTION
.B specs
is a command line utility for parsing and re-arranging text input. It allows re-alignment of fields, some format conversion, and re-formatting multiple lines into single lines or vice versa. Input comes from standard input, and output flows to standard output.
.P 
This is a re-writing of the specs pipeline stage from CMS, only changed quite a bit.
.P 
This version is liberally based on the CMS Pipelines User's Guide and Reference
.URL "https://publib.boulder.ibm.com/epubs/pdf/hcsj0c30.pdf"
-- especially chapters 16, 24, and 20.

.SS "Spec Units"
.B Spec Units 
are the building blocks of a 
.B specs
.I specification.
Each spec unit tells the 
.B specs
engine to perform some action. The most common spec unit is a 
.I data field
which consists of five arguments, three of which may be omitted:
.P
.RS 5
[fieldIdentifier] InputPart [conversion] OutputPart [alignment]
.RE
.P

A 
.B fieldIdentifier 
is a single letter followed by a colon (like
.I a:
), that maps to the input or output of a single data field unit for later reference such as
in later data fields or in 
.I expressions. 
If the fieldIdentifier is at the start of the data field unit, it contains the input. It it
is the OutputPart, it contains the output.  For example:
.RS 5
a: w1 ucase b:
.RE
.I a
contains the first word of the input, while 
.I b
contains an uppercase version of 
.I a

The 
.B InputPart
argument may be any of the following:
.RS 3
.P
A range of characters, such as `5`, `3-7`, or `5.8`, the last one indicating 8 characters starting in the 5th position. Note that the indexing of characters is 1- rather than 0-based.
.P
A range of words, such as `w5` or `words 5-7`, where words are separated by one or more `wordseparator` characters -- locale-defined whitespace by default. The word indexing is 1-based.
.P
A range of fields, such as `fields 5` or `f5-7`, where fields are separated by exactly one `fieldseparator` characters -- a tab by default. The field indexing is 1-based.
.P 
.B TODclock
-- A 64-bit formatted timestamp, giving microseconds since the Unix epoch.
.P 
.B DTODclock
-- A 64-bit formatted timestamp, giving microseconds since the Unix epoch. The difference is that TODclock shows the time when this run of
.I specs
begun, while DTODclock gives the time of producing the current record.
.P
.B NUMBER
-- A record counter as a 10-digit decimal number.
.P
.B TIMEDIFF
-- A 12-digit decimal number indicating the number of microseconds since the invocation of the program.
.P
The 
.B ID
keyword followed by a previously defined 
.B FieldIdentifier.
.P
The 
.B PRINT
keyword followed by a calculated expression
.P
A string literal, optionally enclosed by delimiters, such as `/TODclock/` or `'NUMBER'`. Note that to include the single quotes on the command line requires you to enclose them in double quotes.
.P
A 
.B SUBSTring
of another InputPart.
.RE
    
The 
.B OutputPart
argument specifies where to put the source:
.RS 3
.P
Absolute position (such as `1`) with no limit on output length.
.P
A range (such as `1-5` or `1.5`)
.P
.B N 
or
.B NEXT
for placing the output immediately after the previous output.
.P
.B NW 
or
.B NEXTWORD
for placing the output following a space character after the previous output.
.P
.B NF
or
.B NEXTFIELD
for placing the output following a tab character after the previous output.
.P 
A field identifier specification such as 
.B a:
or
.B C:
\&.
.RE
    
The alignment argument can be `l`, `c`, or `r`, for
.B left
,
.B center
, and
.B right
respectively. Yes, you can use the entire word. In fact, for compatibility with other countries, you can even spell it
.B centre.
.RE
    
The 
.B OutputPart
argument can also be specified as a 
.B Composed Output Placement
argument. It is enclosed in non-optional parenthesis and includes 1, 2, or 3 comma-separated expressions. Those expressions are evaluated at each cycle to produce the starting column, the field width, and the alignment of the field.  If the parenthesis include only one expression, that expression is the starting column. If it contains two expressions, those expressions are the starting column and the width. A width of zero is a special value denoting the normal width of the output. If all three expressions are present, the last one is evaluated as a string, and the alignment will be determined by the value. It will be centered if the argument begins with a capital or lower-case 'c', right-aligned if the value begins with a capital or lower-case 'r', and left-aligned in all other cases.  If the alignment field is two characters in length, the second character is a digit between
.I 1-5,
and the content is longer than the output field, the truncation will use an ellipsis as follows: For a value of
.I 1, 
.B specs 
will output an ellipsis followed by the suffix of the content; for
.I 5,
.B specs
will output a prefix followed by an ellipsis; for 
.I 2, 3, 
and
.I 4,
.B specs
will output a prefix, an ellipsis and a suffix, with the prefix being one third, one half, or two thirds of the output string respectively.  If a composed output placement argument appears in a particular data field, neither a regular OutputPlacement nor an Alignment argument may appear.  The first arguments in a composed output placement can be elided, as in 
.I (,,'R'). 
If that is done, the default for the output start is the next place, equivalent to the function 
.I next(), 
while the default for the second argument is the rest of the line, based on the 
.I @cols
label.

The conversion argument can specify any of the following conversions:
.IP "rot13" 3
Encrypts the bytes using the ROT-13 cipher.
.IP "C2B" 3
Converts characters to binary: "AB" --> "0010000100100010".
.IP "C2X" 3
Converts characters to hexadecimal: "AB" --> "4142".
.IP "B2C" 3
Converts binary to characters: "0010000100100010" --> "AB". Will throw an exception if called with an invalid character.
.IP "X2CH" 3
Converts hexadecimal to characters: "4142" --> "AB". Will throw an exception if called with an invalid character.
.IP "b2x" 3
Converts binary data to hex.
.IP "D2X" 3
Convert decimal to hex: "314159265" --> "12b9b0a1".
.IP "X2D" 3
Convert hex to decimal: "12b9b0a1" --> "314159265".
.IP "ucase" 3
Converts text to uppercase.
.IP "lcase" 3
Converts text to lowercase.
.IP "BSWAP" 3
Byte Swap. reverses the order of bytes. "AB" --> "BA"
.IP "ti2f" 3
Convert internal time format (8-byte microseconds since the epoch) to printable format using the conventions of strftime, plus %xf for fractional seconds, where x represents number of digits from 0 to 6.
.IP "tf2i" 3
Convert printable time format to the internal 8-byte representation. 
.IP "d2tf" 3
Convert a decimal number with up to six decimal places, representing seconds since the epoch, to printable format using the conventions of strftime, plus %xf for fractional seconds, where x represents number of digits from 0 to 6.
.IP "tf2d" 3
Convert printable time format to a decimal number, representing seconds since the epoch. 

.SS "Other Spec Units"
There are also other spec units, that may be used:
.IP "READ" 3
Causes the program to read the next line of input. If we have already read the last line, the read line is taken to be the empty string.
.IP "READSTOP" 3
Causes the program to read the next line of input. If we have already read the last line, no more processing is done for this iteration.
.IP "UNREAD" 3
Causes the program to push back the current active record back to the reader, so that the next iteration of the specification or the next 
.I READ
or
.I READSTOP
spec unit will read it back.  This is useful when looping with READ searching for the next line to run the specification on.
.IP "WRITE" 3
Causes the program to write to output and reset the output line.
.IP "NOWRITE" 3
Causes the program not to suppress the write at the end of the cycle.
.I NOPRINT
is a synonym for 
.I NOWRITE
.IP "NOPRINT" 3
A synonym for 
.I NOWRITE
.IP "ASSERT" 3
Followed by a condition, this keyword halts the specification immediately if the condition evaluates to 
.B false
or zero. The normal use of assertions is to make sure that the read data or the internal state makes sense. 
.IP "ABEND" 3
The 
.I ABnormal END 
keyword is used to abruptly end the run of the specification. The token that follows the ABEND token is output in the error message. ABEND units make sense only within conditionals as they are never part of the normal processing or a record.
.IP "WORDSEPARATOR and FIELDSEPARATOR" 3
Declare a character to be the word of field separator respectively, which affects word and field ranges. For WORDSEPARATOR it is possible to use the special value 
.I default
to make all whitespace defined by the locale work as a word separator. 
.IP "REDO" 3
Causes the current output line to become the new input line.
.IP "SET" 3
Followed by an assignment operation, SET implements this and assigns a value to one of the system counters. See the Expressions and Assignments section.

.SS "Conditions and Loops"
A specification can include conditions and loops. 

Conditions begin with the word 
.B if
followed by an 
.B expression 
that evaluates to true of false, followed by the token
.B then,
followed by some 
.B Spec Units.
Those will be executed only if the condition evaluates to true. They may be followed by an
.B else
token followed by more
.B Spec Units 
that will be executed if the expression is not true, or they may be followed by an
.B elseif
token with its own condition, 
.B then 
token, and set of 
.B Spec Units.
The chain of 
.B elseif
tokens may be arbitrarily long, but there may only be at most one 
.B else
token. The conditional block ends with an
.B endif
token.  For example:

.RS 5
.B if
#2 > 5
.B then 
.RS 4
/big/ 1
.RE 
.B elseif
#2 > 3
.B then 
.RS 4
/medium/ 1
.RE
.B else 
.RS 4
/small/ 1
.RE 
.B endif
.RE

The loop available in 
.B specs
is a 
.B while
loop.  It begins with the 
.B while
token, followed by an 
.B expression 
that evaluates to true of false, followed by the token
.B do,
and a series of 
.B Spec Units
that will be executed as long as the expression evaluates to true. The series of 
.B Spec Units is terminated by the token
.B done.
Example:

.RS 5
.B while
#2 > 0
.B do
.RS 4
print /#2/ 1
.RS 1
.RE 
write
.RS 1
.RE 
set /#2 -= 1/
.RE
.B done
.RE

.SS "Control Breaks"
The 
.B Field Identifiers
have another use. When used with the
.B BREAK
keyword or the 
.B break()
function they act as flow control. A 
.B break level 
is 
.I established
when the value of the corresponding field identifier changes from the previous iteration. For
example, consider a three-field CSV file where the first field is the department name, the second is 
the employee's first name, and the third is his or her last name.  Suppose further that the file is 
sorted by department name. You can print this out without repeating the department name like this:

          FIELDSEPARATOR ,
       c: FIELD 1   .
          FIELD 3  10
          /,/      NEXT
          FIELD 2  NEXTWORD
          BREAK c
              ID c 1

.SS "RunIn and RunOut Cycles"
A 
.B cycle 
is defined as a single run of the specification, which includes reading an input record, processing it, and outputting one or more records. If the specification contains 
.B read 
or 
.B readstop 
tokens, a single cycle can consume more than one input records.

The 
.B runin 
cycle is the first one to run. In the runin cycle, the function 
.B first()
returns 1. This can be used for initial processing such as printing of headers or setting initial values. 

The 
.B runout 
cycle happens 
.I after 
the last line has been read.  It consists of the spec items that follow the 
.B EOF 
token, or (when 
.I select second 
is used) conditional specifications with the 
.B eof() 
function. Example:

    if first() then
        /Item/  1  /Square/ nw write
        /====/  1  /======/ nw write
    endif
    a:  w1 1.4 right
        print "a*a" 6.6 right
        set '#0+=(a*a)'
    EOF
        /==========/ 1 write
        /Total:/ 1
        print #0 nw
        
.SS "Input Streams"
The keyword 
.B SELECT
along with the keywords 
.B FIRST
and
.B SECOND 
can be used to select between two input stations. The 
.B FIRST 
input station is the regular primary input. The
.B SECOND 
input station holds the previous record from the primary input.

Imagine an input stream that has the natural numbers. Let's run the following specification:

    specs w1 1 /- 1 =/ NW SELECT SECOND w1 nw
    
The result will be the following:
    1 - 1 =
    2 - 1 = 1
    3 - 1 = 2
    4 - 1 = 3
    5 - 1 = 4

and so on.

The keyword
.B SELECT
can also be used with a number between 1 and 8 to denote different input streams. These extra streams are specified with the
.B --is2 - --is8
command-line switches to specify the files that contain the other input streams. Every cycle of the specification begins with 
.B specs
set to stream #1.  For example, suppose we have two files: f1 and f2, both of which contain lists of numbers, and we want to add them:

    specs -i f1 --is2 f2 a: W1 1 '+' NW  SELECT 2  b: W1 NW  '=' NW  PRINT "a+b" NW
    
If both files contained the natural numbers we would get the following output:
    1 + 1 = 2
    2 + 2 = 4
    3 + 3 = 6
    4 + 4 = 8
    5 + 5 = 10

and so on.

.SS "Output Streams"
The keyword
.B OUTSTREAM
can be used to select between multiple output streams. Output stream number #1 is the primary default output stream. Output streams #2 through #8 can be files specified with the
.B --os2 - --os8
command-line switches.  There is one additional output stream, which is the standard error.  It is selected with the keyword
.B STDERR
for a total of up to 9 output streams.  Example:

    ls -l | specs --os2 filesizes --os3 owners 
                W9 1 WRITE 
                OUTSTREAM 2 W5 1 WRITE
                OUTSTREAM 3 w3 1
                
This specification will print the list of owners to file 
.I owners
the file sizes to file
.I filesizes
and the file names to standard output.

.SS "Expressions and Assignments"
Expressions are used in PRINT data units as well as in assignments. Assignments are used in SET Spec Units.

Expressions are made up of numbers, field identifiers (no colon needed), and counter numbers preceded by a hash mark. They allow ordinary arithmetic and logical operations as well as function calls for pre-defined functions:
.IP "Unary Operators" 3
+ (plus - does nothing), - (minus), ! (logical NOT)
.IP "Binary Arithmetic Operators" 3
+, -, *. / (division), // (integer division), % (remainder)
.IP "Binary String Operator" 3
|| (string append)
.IP "Binary Arithmetic/String Logical Operators" 3
<, >, <=, >=, =, !=
.IP "Binary Strict Logical Operators" 3
<<, >>, <<=, >>=, ==. !==
.IP "Binary Logical Operators" 3
& (AND), | (OR)

.P 
Assignments assign the result of an expression into a 
.I numbered counter. 
For example:

	#3 := b+3
.P	
Assignment can also be used as expressions. When used as such, the value returned is the content of the counter after executing the assignment. For example, the following specification:

    specs print "#0:=2+2" 1
    
will output 4.  The assignment is performed and the value stored in the counter.
	
.IP "Assignment Operators" 3
:=, +=, -=, *=, /=, //=, %=, ||=

.IP "At-sign (@) Operator" 3
The at-sign allows the inclusion of user-defined and system-defined labels as strings in expressions. The double at-sign (@@) substitutes for the entire input record.

.SS "Built-In Functions"
.IP "abs(x)" 3
The absolute function returns the absolute value of the number passed to it. Will return an integer if the parameter is integer, or float otherwise.
.IP "ceil(x), floor(x), round(x), roundd(x,d)" 3
These function return the closest numbers to 
.I x
:
.B ceil
returns a whole number no smaller than 
.I x
;
.B floor
returns a whole number no greater than 
.I x
;
.B round
returns a whole number closest to 
.I x
; 
and
.B roundd
returns a number with up to
.I d
decimal places closest to 
.I x
, 
.IP "frand()" 3
The floating-point random function returns a random value no smaller than 0.0 and smaller than 1.0.
.IP "fmt(value,format,digits,decimal,separator)" 3
The
.B fmt
function formats a floating-point
.B value
as a string. The 
.B format 
argument can be omitted, or it can begin with 
.I f
for a 
.I fixed 
number of 
.B digits
after the decimal point, or
.I s
for 
.I scientific
notation. When omitted, the 
.B digits
argument sets the total number of digits displayed. The 
.B decimal
argument sets the character used for the decimal point (default is a period), while the 
.B separator
argument sets the character used as thousands separator (default is none).
.IP "pow(x,y)" 3
The power function returns x to the power of y. Much like arithmetic operations, if either operand is float, the result is a float. If both operands are integers, the result is an integer. Otherwise, if both operands are whole numbers, the result is integer, otherwise it is float.
.IP "rand(x)" 3
The random function returns a random integer value between 0 up to and not including x.
.IP "sin(x), cos(x), tan(x), dsin(x), dcos(x), dtan(x)" 3
These trigonometric functions return the sine, cosine and tangent of an angle.
.B sin, cos,
and
.B tan
accept an argument in radians, while
.B dsin, dcos,
and
.B dtan 
accept an argument in degrees.
.IP "arcsin(x), arccos(x), arctan(x), arcdsin(x), arcdcos(x), arcdtan(x)" 3
These trigonometric functions return the inverse sine, cosine and tangent.
.B arcsin, arccos,
and
.B arctan
return an angle in radians, while
.B arcdsin, arcdcos,
and
.B arcdtan 
return an angle in degrees.
.IP "string(x)" 3
Returns the same value as the argument, but forced to be stored as a string. There is nothing preventing this from later evaluating as a number, so
.I string(3)+2
will evaluate to 5.
.IP "substitute(haystack,needle,subst,max)"
Returns the string in 
.I haystack
where every occurence of 
.I needle
is replaced by the string 
.I subst
for at most 
.I max
times. The special value 
.B """U"""
for 
.I max
is used to indicate that all occurrences should be replaced.
.IP "sqrt(x)" 3
The square root function always returns a float.
.IP "c2u(x)" 3
Returns an unsigned decimal number from the binary representation of x.
.IP "c2d(x)" 3
Returns a signed decimal number from the binary representation of x.
.IP "c2f(x)" 3
Returns a floating point number assuming that x is a binary representation of a floating point number in the native encoding of the platform. On most platforms valid lengths are 4, 8, and 16 bytes (32, 64, and 128 bits).
.IP "frombin(x)" 3
Returns a decimal number from the binary representation in x.
.IP "tobine(x,d)" 3
Returns a binary representation of the unsigned integer in x with field of length d bits. Valid values for d are 8, 16, 32, and 64.
.IP "tobin(x)" 3
Returns a binary representation of the unsigned integer in x. The field length is automatically determined by the value of x, but will be 1, 2, 4, or 8 characters in length.
.IP "length(x)" 3
Returns the length of the argument when viewed as a string. For example, len(37) is 2; len('hello') is 5.
.IP "first()" 3
Returns 1 during the 
.B runin
cycle, and zero otherwise.
.IP "eof()" 3
Returns 1 during the
.B runout 
cycle, and zero otherwise.
.IP "number()" 3
Returns the number of times the specification has so far been run on different records.
.IP "recno()" 3
Returns the number of input records that have been read so far. If the specification contains no 
.I READ
or
.I READSTOP
spec units, then this number will be equal to the result of 
.B number().
Otherwise, it will be higher.
.IP "record()" 3
Returns the entire input record. Equivalent to 
.B range(1,-1)
.IP "range(s,e)" 3
Returns the range of characters from
.B s
(default first) to 
.B e 
(default last) from the input record. If the end of the range exceeds the end, truncates the result at the end. If the start of the range exceeds the end, or if the start is smaller than the end, returns NaN.
.IP "wordcount()" 3
Returns the count of words in the input record.
.IP "word(i)" 3
Returns the i-th word in the input record.
.IP "wordstart(i)" 3
Returns the starting position of the i-th word in the input record.
.IP "wordend(i)" 3
Returns the ending position of the i-th word in the input record. 
.I range(wordstart(i),wordend(i))
is equivalent to 
.I word(i)
but less efficient.
.IP "wordrange(s,e)" 3
Returns the string from the start of the 
.B s-th
word to the end of the 
.B e-th 
word. It is also equivalent to 
.I range(wordstart(s),wordend(e))
but less efficient.
.IP "fieldcount()" 3
Returns the count of fields in the input record.
.IP "field(i)" 3
Returns the i-th field in the input record.
.IP "fieldstart(i)" 3
Returns the starting position of the i-th field in the input record.
.IP "fieldend(i)" 3
Returns the ending position of the i-th field in the input record. 
.I range(fieldstart(i),fieldend(i))
is equivalent to 
.I field(i)
but less efficient.
.IP "fields(s,e)" 3
Returns the string from the start of the 
.B s-th
field to the end of the 
.B e-th 
field. It is also equivalent to 
.I range(fieldstart(s),fieldend(e))
but less efficient.
.IP "tf2d(string,format)" 3
Converts a string containing a date and time representation using the format specified in the 
.I format
argument to a floating point or integer number representing the number of seconds since the UNIX epoch. Formatting is as described for the similarly named conversion.
.IP "d2tf(seconds,format)" 3
Converts a number (integer or float) representing the number of seconds since the UNIX epoch to a printable format.
.IP "x2d(string,length)" 3
Returns the value in 
.I string
converted to decimal. If 
.I length is missing or non-positive, the resulting decimal is signed, otherwise it is unsigned.
.IP "next()" 3
Returns the column of the next character to print if a
.I spec unit
specifies the 
.B NEXT
position.

.SS "Built-In String Functions"
.IP "abbrev(information, info)" 3
Returns
.I 1
if 
.B information
begins with the characters of 
.B info
or 
.I 0 
otherwise.
.IP "abbrevl(information, info, len)" 3
Returns
.I 1
if 
.B information
begins with the first
.B len
characters of 
.B info
or 
.I 0 
otherwise.
.IP "substr(bigstring, start, length)" 3
Returns a substring of 
.I bigstring
starting at offset 
.I start
with a length of 
.I length
. If the length exceeds the end of the string, it is truncated. As always in 
.B specs
the indexes are 1-based. Negative indexes can be used to indicate offsets from the end of the string.
.IP "left(bigstring, length)" 3
Returns
.I length
characters starting at the beginning of 
.I bigstring.
If the length exceeds the length of bigstring, the result will be right-padded with blanks. If the 
length is negative, the length of the string + 1 will be added to it, so 
.B left(bigstring,-3)
is the entire string less the last two characters.
.IP "right(bigstring, length)" 3
Returns the last
.I length
characters of 
.I bigstring.
If the length exceeds the length of bigstring, the result will be left-padded with blanks. If the 
length is negative, the length of the string + 1 will be added to it, so 
.B right(bigstring,-3)
is the entire string less the first two characters.
.IP "center(bigstring, length)" 3
Returns
.I length
consecutive characters from
.I bigstring
as centered as possible in the string. If the length exceeds the length of bigstring, the result will be right-padded and left-padded with blanks. If the 
length is negative, the length of the string + 1 will be added to it, so 
.B center(bigstring,-3)
is the entire string less the first and last characters. This function can also be spelled 
.B centre
because the CMS Pipelines version also does so.
.IP "pos(needle, haystack)" 3
Returns the 1-based index of the 
.B first 
position of 
.I needle
in 
.I haystack.
.IP "lastpos(needle, haystack)" 3
Returns the 1-based index of the 
.B last 
position of 
.I needle
in 
.I haystack.
.IP "includes(haystack, needle)" 3
Returns
.B TRUE
(1) if the string 
.I haystack
includes the string
.I needle
as a substring, or 
.B FALSE
(0) otherwise.
.IP "conf(key)" 3
Returns the configured string from either the built-in configured strings such as 
.I version
or from the 
.B $HOME/.specs
file.
.IP "sfield(str,n,sep)" 3
Returns the n-th field of string
.I str
counting from the start or end of the string depending on the sign of n. Separator is the first char of 
.I sep
if non-empty, or 
.B tab
otherwise.
.IP "sword(str,n,sep)" 3
Returns the n-th word of string
.I str
counting from the start or end of the string depending on the sign of n. Separator is the first char of 
.I sep
if non-empty, or 
.B space
otherwise.

.SS "Built-In REXX-Derived Functions"
.IP "bitand(x,y)" 3
Returns the bit-wise 
.B AND
of 
.I x
and 
.I y
If the length is not equal, the return string has the minimum length.
.IP "bitor(x,y)" 3
Returns the bit-wise 
.B OR
of 
.I x
and 
.I y
If the length is not equal, the return string has the minimum length.
.IP "bitxor(x,y)" 3
Returns the bit-wise 
.B XOR
of 
.I x
and 
.I y
If the length is not equal, the return string has the minimum length.
.IP "compare(s1,s2)" 3
Returns the index of the first mis-matched character in strings 
.I s1
and
.I s2
If the strings are equal, the function returns
.B zero.
If the strings are of unequal length, the shorter string is padded with spaces.
.IP "comparep(s1,s2,pad)" 3
Returns the index of the first mis-matched character in strings 
.I s1
and
.I s2
If the strings are equal, the function returns
.B zero.
If the strings are of unequal length, the shorter string is padded with the pad character.
.IP "copies(string,times)" 3
Returns the content of
.I string 
repeated
.I times
times.
.IP "delstr(string,start,length)" 3
Deletes the substring of 
.I string 
that starts at position 
.I start 
for the specified 
.I length. 
If 
.I length 
is zero, the rest of the string is deleted from position start to the end.
.IP "delword(string,start,length)" 3
Deletes the substring of 
.I string 
that starts at position 
.I start 
and is of length 
.I length 
blank-delimited words. If 
.I length 
is zero, it defaults to removing the rest of the words in 
.I string.
.IP "find(string,phrase)" 3
Returns the word number of the first occurrence of 
.I phrase 
in 
.I string. 
Returns 0 if 
.I phrase 
is not found. Multiple blanks between words are treated as one in comparisons.
.IP "index(haystack,needle,start)" 3
Returns the character position of 
.I needle
within string
.I haystack. 
Returns 0 if 
.I needle 
is not found. If positive, 
.I start tells where in
.I haystack 
to initiate the search. It defaults to 1 if not specified. The standard
.B pos 
function should be used instead of 
.B index 
if possible.
.IP "insert(string,target,position,length)" 3 
Inserts 
.I string
into 
.I target
at position 
.I position 
and truncated or padded with spaces to length 
.I length. 
With default zero values, 
.I position 
inserts the 
.I string 
at the start of 
.I target, 
and the length of the 
.I string
is kept as is.
.IP "insertp(string,target,position,length,pad)" 3 
Inserts 
.I string
into 
.I target
at position 
.I position 
and truncated or padded with 
.I pad
characters to length 
.I length. 
With default zero values, 
.I position 
inserts the 
.I string 
at the start of 
.I target, 
and the length of the 
.I string
is kept as is.
.IP "justify(string,length)" 3
Evenly justifies words within 
.I string. 
The 
.I length
specifies the length of the returned string.
.IP "justifyp(string,length,pad)" 3
Evenly justifies words within 
.I string. 
The 
.I length
specifies the length of the returned string, while
.I pad
specifies what padding to insert (if necessary).
.IP "overlay(string1, string2 ,start ,length ,pad)" 3
Returns a copy of 
.I string2, 
partially or fully overwritten by 
.I string1. start 
specifies the starting position of the overlay. 
.I length 
truncates or pads 
.I string1 
prior to the operation, using 
.I pad 
as the pad character.
.IP "reverse(string)" 3
Returns a copy of a 
.I string 
with its characters reversed.
.IP "sign(number)" 3
Returns 1 if the 
.I number 
is positive, 0 if the 
.I number 
is 0, and -1 if the 
.I number 
is negative.
.IP "space(string,length,pad)" 3
Formats a 
.I string 
by replacing internal blanks with 
.I length 
occurrences of the 
.I pad 
character. The default pad character is blank and the default length is 1. Leading and trailing blanks are always removed. If 
.I length 
is 0, all blanks are removed.
.IP "strip(string,option,char)" 3
Returns 
.I string 
stripped of leading and/or trailing blanks or any other 
.I char 
specified. 
.I Option 
values determine the action:
.B L
for leading, 
.B T
for trailing, and
.B B
for both.
.IP "subword(string,start,length)" 3
Returns the substring that begins at blank-delimited word 
.I start. 
If
.I length is omitted, it defaults to the remainder of the string.
.IP "translate(string,tableout,tablein,pad)" 3
Returns a translated copy of 
.I string. 
Characters are translated according to the input translation table 
.I tablein 
and its output equivalent, 
.I tableout. 
If 
.I tablein 
and 
.I tableout 
are not coded, all characters in 
.I string 
are translated to uppercase. If 
.I tableout 
is shorter than 
.I tablein, 
it is padded with the 
.I pad 
character or its default, blanks.
.IP "verify(string, reference ,option ,start)" 3
Verifies that all characters in 
.I string 
are members of the 
.I reference 
string. Returns the position of the first character in 
.I string t
hat is not in 
.I reference, 
or 0 if all characters in 
.I string 
are in 
.I reference. 
.P
.I start 
specifies where in 
.I string 
to start the search, the default is 1. The option may be:
.RS 3
.P
.B N 
or Nomatch — Default. Works as described earlier.
.P
.B M
or Match — Returns the position of the first character in string that is in reference.
.IP "wordindex(string,wordno)" 3
Returns the character position of the first character of the blank-delimited word given by word number 
.I wordno 
within 
.I string. 
Returns 0 if the word numbered 
.I wordno 
does not exist in the 
.I string.
.IP "wordlength(string,wordno)" 3
Returns the length of the blank-delimited word given by word number 
.I wordno 
within 
.I string. 
Returns 0 if the word numbered 
.I wordno 
does not exist in the 
.I string.
.IP "wordpos(phrase, string [,start])" 3
If 
.I phrase 
is a substring of 
.I string, 
returns the word number position at which it begins. Otherwise returns 0. 
.I start 
is an optional word number within 
.I string 
at which the search starts. It defaults to 1.
.IP "words(string)" 3
Returns the number of blank-delimited words within the 
.I string.
.IP "xrange(start,end)" 3
Returns a string composed of all the characters between 
.I start 
and 
.I end 
inclusive. 
.I start 
defaults to 0x00, and 
.I end
defaults to 0xff.


.SS "Built-In Statistical Pseudo-Functions" 
All of the below functions work on the values stored in field identifiers. You cannot place a proper expression inside the parenthesis.
.IP "present(a)" 3
Returns 
.I 1
if the
.B Field Identifier
a is set, or
.I 0
otherwise. 
.IP "sum(a)" 3
Returns the sum of all values in
.B Field Identifier
a. 
.IP "min(a)" 3
Returns the minimum of all values in
.B Field Identifier
a. 
.IP "max(a)" 3
Returns the maximum of all values in
.B Field Identifier
a. 
.IP "average(a)" 3
Returns the average (mathematical mean) of all values in
.B Field Identifier
a. 
.IP "variance(a)" 3
Returns the 
.I variance 
(the expectation of the squared deviation of a random variable from its mean) of the values in
.B Field Identifier
a. 
.IP "stddev(a)" 3
Returns the 
.I standard deviation 
(square root of the variance) of the values in
.B Field Identifier
a. 
.IP "stderrmean(a)" 3
Returns the 
.I standard error 
(standard deviation divided by sample size minus 1) of the values in
.B Field Identifier
a. 
.IP "fmap_nelem(a)" 3
Returns the number of distinct values of
.B Field Identifier
a. 
.IP "fmap_nsamples(a)" 3
Returns the number of samples collected of
.B Field Identifier
a. 
.IP "fmap_common(a)" 3
Returns the string value with most occurrences of
.B Field Identifier
a. In case of a tie, one of the values is returned.
.IP "fmap_rare(a)" 3
Returns the string value with least but non-zero occurrences of 
.B Field Identifier
a. In case of a tie, one of the values is returned.
.IP "fmap_count(a,s)" 3
Returns the number of occurences of the 
.B string 
s in
.B Field Identifier
a. 
.IP "fmap_frac(a,s)" 3
Returns the fraction of
.B Field Identifier
a values that are equal to the
.B string 
s.
.IP "fmap_pct(a,s)" 3
Returns the fraction of
.B Field Identifier
a values that are equal to the
.B string 
s.
.IP "fmap_sample(a,s)" 3
Treats the value of the 
.B string 
s as a new sample for
.B Field Identifier
a. Returns the count of occurences of s. 
.IP "fmap_dump(a,format,sortOrder,showPct)" 3
Returns a string containing a dump of the frequency map for
.B Field Identifier
a.

.SH OPTIONS
specs supports the following switches:
.IP "--toASCII" 3
Causes output to be translated into ASCII if it's outside the range.
.IP "--force-read-input" 3
Forces specs to read every input line even if none of the spec units use it. By default it won't.
.IP "--specFile or -f" 3
Makes the program read the specification from a file rather than the command line. This is useful both for reusing specifications and for long specifications. It also relieves the plumber from having to escape a lot of characters in the specification to avoid creative interpretation by the Unix shell.
You can specify the full path of the files, or 
.B specs 
will search the 
.I SPECSPATH 
for them. The 
.I SPECSPATH 
can be set from either the environment variable 
.B SPECSPATH 
or the configuration string 
.B SPECSPATH. 
In both cases the syntax is just like the OS 
.B PATH: 
a list of directories separated by colons.
.IP "--verbose or -v" 3
Outputs more information when something goes wrong.
.IP "--stats"
Output statistics on run time, and records read, and on records written to standard error.
.IP "--inFile or -i" 3
Makes the program read the input records from a file rather than from standard input.
.IP "--outFile or -o" 3
Makes the program write the output records to a file rather than to standard output.
.IP "--spaceWS" 3
Makes the program treat the only spaces as the default word separator. Otherwise all locale-defined whitespace is treated as the default word separator.
.IP "--debug-alu-comp" 3
Prints out detailed information about the parsing and compiling of expressions (
.I only in debug build
).
.IP "--debug-alu-run" 3
Prints out detailed step-by-step information about the evaluation of expressions (
.I only in debug build
).   
.IP "--config or -c" 3
Changes the configuration file from the default 
.I ~/.specs
to whatever the parameter says
.IP "--timezone" 3
Changes the timezone from the default which is the current timezone to the value specified.
.IP "--recfm" 3
Sets the record format for the primary input stream. Supported options are 
.B D (delimited)
for records delimited by a character in the input stream (this is the default); 
.B F (fixed)
for records or a fixed length (see --lrecl); 
.B FD (fixed-delimited)
for records delimited as in 
.B fixed,
but truncated or padded to a fixed length.
.IP "--lrecl" 3
Sets the record length for 
.B fixed
and
.B fixed-delimited
records.
.IP "--linedel" 3
For 
.B delimited
and
.B fixed-delimited
records, sets the character that delimits the string. The OS-specific delimiter (CR+LF for Unix-like) is used if this is not specified.

.SH CONFIGURATION FILE
.B specs
reads a configuration file by default from 
.B $HOME/.specs
.P 
This file contains some configuration options. For now, it only allows you to set user-predefined labels and three specific configuration options: 
.B timezone, 
.B locale, 
and 
.B SPECSPATH. 
For example, an entry such as this:
.P
    timezone: "Europe/Belfast"
    locale: es_ES
    SPECSPATH: /home/myself/specs:/Library/specs
    myCA: "Honest Abe's Used Cars & Certificates"
.P
allows you to issue a 
.B specs
command like this:
.P
    specs /My certificates come from/ 1 @myCA nw 
    
.SS "System-Defined Labels"
The system also defines some labels:
.IP "version" 3
This returns the version of 
.B specs, 
for example "v0.5"
.P
To find out the version of specs that you are using, use the following command:
.P 
    specs @version 1
.IP "cols" 3
contains the number of columns in the display. You can override this in the configuration file. For example, the following prints a right-justified string. 
.P
    specs /hello/ (1,@cols,'R')
.IP "rows" 3
contains the number of rows in the display. This can also be overridden in the configuration file.

    
.SH EXAMPLES
`ls -l` yields this:

    total 352
    -rw-r--r--@ 1 ynir  admin    574 Aug 25  2009 Makefile
    -rw-r--r--@ 1 ynir  admin   3542 Nov 23 00:21 README
    -rw-r--r--@ 1 ynir  admin    362 Nov 19 08:31 conversion.h
    -rw-r--r--  1 ynir  admin    984 Nov 11 17:45 ls.txt
    -rw-r--r--@ 1 ynir  admin   2233 Nov 23 00:03 main.cc
    -rw-r--r--  1 ynir  admin   9412 Nov 23 00:11 main.o
    -rw-r--r--@ 1 ynir  admin   6567 Nov 23 00:09 spec_build.cc
    -rw-r--r--  1 ynir  admin  16776 Nov 23 00:11 spec_build.o
    -rw-r--r--@ 1 ynir  admin   5494 Nov 19 08:30 spec_convert.cc
    -rw-r--r--  1 ynir  admin  17004 Nov 23 00:11 spec_convert.o
    -rw-r--r--@ 1 ynir  admin  11419 Nov 23 00:10 spec_params.cc
    -rw-r--r--  1 ynir  admin  21080 Nov 23 00:11 spec_params.o
    -rw-r--r--@ 1 ynir  admin    375 Nov 11 09:29 spec_vars.cc
    -rw-r--r--  1 ynir  admin   4800 Nov 23 00:11 spec_vars.o
    -rwxr-xr-x  1 ynir  admin  36740 Nov 23 00:11 specs
    -rw-r--r--@ 1 ynir  admin   1547 Nov 23 00:10 specs.h

Let's run it though a spec:

    ls -l | specs 12-* 1 redo w2 1 w4 d2x 8.8 r w8 17
    
The first spec unit converts it to this:

    1 ynir  admin    574 Aug 25  2009 Makefile
    1 ynir  admin   3542 Nov 23 00:21 README
    1 ynir  admin    362 Nov 19 08:31 conversion.h
    1 ynir  admin    984 Nov 11 17:45 ls.txt
    1 ynir  admin   2233 Nov 23 00:03 main.cc
    1 ynir  admin   9412 Nov 23 00:11 main.o
    1 ynir  admin   6567 Nov 23 00:09 spec_build.cc
    1 ynir  admin  16776 Nov 23 00:11 spec_build.o
    1 ynir  admin   5494 Nov 19 08:30 spec_convert.cc
    1 ynir  admin  17004 Nov 23 00:11 spec_convert.o
    1 ynir  admin  11419 Nov 23 00:10 spec_params.cc
    1 ynir  admin  21080 Nov 23 00:11 spec_params.o
    1 ynir  admin    375 Nov 11 09:29 spec_vars.cc
    1 ynir  admin   4800 Nov 23 00:11 spec_vars.o
    1 ynir  admin  36740 Nov 23 00:11 specs
    1 ynir  admin   1547 Nov 23 00:10 specs.h

Then after the redo, we get this:

    ynir        23e Makefile
    ynir        dd6 README
    ynir        16a conversion.h
    ynir        3d8 ls.txt
    ynir        8b9 main.cc
    ynir       24c4 main.o
    ynir       19a7 spec_build.cc
    ynir       4188 spec_build.o
    ynir       1576 spec_convert.cc
    ynir       426c spec_convert.o
    ynir       2c9b spec_params.cc
    ynir       5258 spec_params.o
    ynir        eae spec_vars.cc
    ynir       12c0 spec_vars.o
    ynir       8f84 specs
    ynir        60b specs.h

      
Alternatively, let's arrange this on multiple lines:

    ls -l | specs w9 1 write "Owner:" 3 w3 10 write "Size:" 3 w5 10-20 r

    Makefile
      Owner: ynir
      Size:          574
    README
      Owner: ynir
      Size:         5834
    conversion.h
      Owner: ynir
      Size:          362
    list.txt
      Owner: ynir
      Size:          978
    ls.txt
      Owner: ynir
      Size:          984
    main.cc
      Owner: ynir
      Size:         2233
    main.o
      Owner: ynir
      Size:         9412

Finally, let's make our own version of the multi-column display:

    ls -l | specs w9 1 read w9 26 read w9 51
                             Makefile                 README
    conversion.h             main.cc                  main.o
    spec_build.cc            spec_build.o             spec_convert.cc
    spec_convert.o           spec_params.cc           spec_params.o
    spec_vars.cc             spec_vars.o              specs
    specs.h


.SH SEE ALSO
sed(1), awk(1)
.SH BUGS
Too many to list here, but it's getting better.
.SH AUTHOR
Yoav Nir (yoav.nir@gmail.com)